// --- DATA STORE: Static Info for complexities ---
const TOPIC_DATA = {
  stack: {
    title: "Stack",
    type: "Linear",
    desc: "A LIFO (Last In First Out) data structure. Elements are added and removed from the same end.",
    time: "Access: O(n), Search: O(n), Insert/Delete: O(1)",
    space: "O(n)",
    code: `const stack = [];\nstack.push(10);\nstack.pop();`,
  },

  bst: {
    title: "Binary Search Tree",
    type: "Non-Linear",
    desc: "A hierarchical structure where each node has at most two children. The left child is smaller than the parent, and the right child is larger.",
    time: "Access/Search/Insert/Delete: O(log n) average, O(n) worst case",
    space: "O(n)",
    code: `class Node {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}`,
  },
  array: {
    title: "Array",
    type: "Linear",
    desc: "A collection of elements identified by index or key. Elements are stored in contiguous memory locations.",
    time: "Access: O(1), Search: O(n), Insert/Delete: O(n)",
    space: "O(n)",
    code: `const arr = [1, 2, 3];\narr[1]; // Access\narr.push(4); // Insert`,
  },
  linkedList: {
    title: "Linked List",
    type: "Linear",
    desc: "A linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next.",
    time: "Access/Search: O(n), Insert/Delete: O(1) (if pointer known)",
    space: "O(n)",
    code: `class Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}`,
  },
  queue: {
    title: "Queue",
    type: "Linear",
    desc: "A FIFO (First In First Out) structure. Elements are added at the back (enqueue) and removed from the front (dequeue).",
    time: "Access/Search: O(n), Enqueue/Dequeue: O(1)",
    space: "O(n)",
    code: `const queue = [];\nqueue.push(10); // Enqueue\nqueue.shift(); // Dequeue`,
  },
  // ... keep existing linear data ...
  simpleTree: {
    title: "Simple Tree (N-ary)",
    type: "Non-Linear",
    desc: "A generic hierarchy. Each node can have any number of children. No specific ordering rules.",
    time: "Search/Access: O(n)",
    space: "O(n)",
    code: `class Node {\n  constructor(val) {\n    this.val = val;\n    this.children = [];\n  }\n}`,
  },
  binaryTree: {
    title: "Binary Tree",
    type: "Non-Linear",
    desc: "A tree where each node has at most two children (Left and Right).",
    time: "Search: O(n) (BFS/DFS)",
    space: "O(n)",
    code: `class Node {\n  this.left = null;\n  this.right = null;\n}`,
  },
  bst: {
    title: "Binary Search Tree",
    type: "Non-Linear",
    desc: "Left child < Parent < Right child. Efficient for lookups.",
    time: "Avg: O(log n), Worst: O(n)",
    space: "O(n)",
    code: `if (val < node.val) goLeft();\nelse goRight();`,
  },
  avl: {
    title: "AVL Tree",
    type: "Non-Linear",
    desc: "Self-balancing BST. Maintains height difference ≤ 1. Guarantees O(log n) search.",
    time: "All ops: O(log n)",
    space: "O(n)",
    code: `balanceFactor = height(L) - height(R);\nif (bf > 1) rotateRight();`,
  },
  bTree: {
    title: "B-Tree",
    type: "Non-Linear",
    desc: "Self-balancing search tree. Nodes contain multiple keys and children. Optimized for disk read/write.",
    time: "Search/Insert: O(log n)",
    space: "O(n)",
    code: `// Node splits when full (keys > order-1)`,
  },
  bPlusTree: {
    title: "B+ Tree",
    type: "Non-Linear",
    desc: "Variation of B-Tree. All data stored in leaves. Leaves are linked for fast range queries.",
    time: "Range Search: Very Fast",
    space: "O(n)",
    code: `// Internal nodes = keys only\n// Leaves = keys + data + nextPtr`,
  },
  undirectedGraph: {
    title: "Undirected Graph",
    type: "Non-Linear",
    desc: "A set of vertices (nodes) connected by edges, where edges have no direction. The connection is symmetric (A-B is the same as B-A).",
    time: "Adjacency List: O(V+E) for BFS/DFS",
    space: "O(V+E)",
    code: `// Adjacency List\ngraph[u].push(v);\ngraph[v].push(u);`,
  },
  directedGraph: {
    title: "Directed Graph (Digraph)",
    type: "Non-Linear",
    desc: "A graph where edges have a specific direction (u → v). Traversing from u to v is possible, but not necessarily vice versa.",
    time: "Search: O(V+E)",
    space: "O(V+E)",
    code: `graph[u].push(v); // One way`,
  },
  weightedGraph: {
    title: "Weighted Graph",
    type: "Non-Linear",
    desc: "A graph where every edge has a numerical value (weight) assigned to it, often representing cost, distance, or time.",
    time: "Pathfinding varies (e.g. Dijkstra)",
    space: "O(V+E)",
    code: `graph[u].push({ node: v, weight: 5 });`,
  },
  bubbleSort: {
    title: "Bubble Sort",
    type: "Algorithm",
    desc: "A sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
    time: "Best: O(n), Average: O(n²), Worst: O(n²)",
    space: "O(1)",
    code: `for (let i = 0; i < n; i++) {\n  for (let j = 0; j < n-i-1; j++) {\n    if (arr[j] > arr[j+1]) swap();\n  }\n}`,
  },
  selectionSort: {
    title: "Selection Sort",
    type: "Algorithm",
    desc: "Repeatedly finds the minimum element from the unsorted part and puts it at the beginning.",
    time: "O(n²)",
    space: "O(1)",
    code: `for(i=0; i<n; i++) {\n  min = i;\n  for(j=i+1; j<n; j++)\n    if(arr[j] < arr[min]) min=j;\n  swap(i, min);\n}`,
  },
  insertionSort: {
    title: "Insertion Sort",
    type: "Algorithm",
    desc: "Builds the sorted array one item at a time by shifting larger elements to the right.",
    time: "O(n²)",
    space: "O(1)",
    code: `for(i=1; i<n; i++) {\n  key = arr[i];\n  j = i-1;\n  while(j>=0 && arr[j]>key)\n    arr[j+1] = arr[j]; j--;\n  arr[j+1] = key;\n}`,
  },
  quickSort: {
    title: "Quick Sort",
    type: "Algorithm",
    desc: "Divide and Conquer. Picks a 'pivot' and partitions the array so smaller elements are left, larger are right.",
    time: "Avg: O(n log n), Worst: O(n²)",
    space: "O(log n) (recursion stack)",
    code: `pivot = partition(arr, low, high);\nquickSort(arr, low, pivot-1);\nquickSort(arr, pivot+1, high);`,
  },
  linearSearch: {
    title: "Linear Search",
    type: "Algorithm",
    desc: "Iterates through the collection one by one until the target is found.",
    time: "O(n)",
    space: "O(1)",
    code: `for(x of arr) if(x == target) return true;`,
  },
  binarySearch: {
    title: "Binary Search",
    type: "Algorithm",
    desc: "Efficiently finds a target in a SORTED array by repeatedly dividing the search interval in half.",
    time: "O(log n)",
    space: "O(1)",
    code: `mid = (L+R)/2;\nif(arr[mid] < target) L=mid+1;\nelse R=mid-1;`,
  },
  fibDP: {
    title: "DP: Fibonacci (Memoization)",
    type: "Algorithm",
    desc: "Demonstrating Dynamic Programming by storing results of subproblems to avoid redundant calculations.",
    time: "O(n)",
    space: "O(n)",
    code: `if(memo[n]) return memo[n];\nmemo[n] = fib(n-1) + fib(n-2);\nreturn memo[n];`,
  },
};

export default TOPIC_DATA;
